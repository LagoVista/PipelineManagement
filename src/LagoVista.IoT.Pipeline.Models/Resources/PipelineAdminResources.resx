<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Common_Description" xml:space="preserve">
    <value>Descrption</value>
  </data>
  <data name="Common_IsPublic" xml:space="preserve">
    <value>Is Public</value>
  </data>
  <data name="Common_Key" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="Common_Key_Help" xml:space="preserve">
    <value>The key is used to identify this item in scripts and must be unique with respect to it's parent. One a key has been assigned, it can not be changed.</value>
  </data>
  <data name="Common_Key_Validation" xml:space="preserve">
    <value>The key must use only letters and numbers, and must be lowercase and must be between 3 and 20 characters.</value>
  </data>
  <data name="Common_Name" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="Common_Notes" xml:space="preserve">
    <value>Notes</value>
  </data>
  <data name="Common_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="Connection_Select_Type" xml:space="preserve">
    <value>-select connection type-</value>
  </data>
  <data name="Connection_Type_AMQP" xml:space="preserve">
    <value>AMQP Client</value>
  </data>
  <data name="Connection_Type_AzureEventHub" xml:space="preserve">
    <value>Azure Event Hub</value>
  </data>
  <data name="Connection_Type_AzureIoTHub" xml:space="preserve">
    <value>Azure IoT Hub</value>
  </data>
  <data name="Connection_Type_AzureServiceBus" xml:space="preserve">
    <value>Azure Service Bus</value>
  </data>
  <data name="Connection_Type_Custom" xml:space="preserve">
    <value>Custom</value>
  </data>
  <data name="Connection_Type_MQTT_Broker" xml:space="preserve">
    <value>MQTT Broker</value>
  </data>
  <data name="Connection_Type_POP3Server" xml:space="preserve">
    <value>POP3 Server</value>
  </data>
  <data name="Connection_Type_Rest" xml:space="preserve">
    <value>REST</value>
  </data>
  <data name="Connection_Type_Soap" xml:space="preserve">
    <value>SOAP</value>
  </data>
  <data name="Connection_Type_TCP" xml:space="preserve">
    <value>TCP</value>
  </data>
  <data name="Connection_Type_UDP" xml:space="preserve">
    <value>UDP</value>
  </data>
  <data name="CustomModule_Description" xml:space="preserve">
    <value>A Custom Module is Pipeline Execution Module that can be developed in any language that supports .NET and uploaded to the system</value>
  </data>
  <data name="CustomModule_Help" xml:space="preserve">
    <value>A Custom Module is Pipeline Execution Module that can be developed in any language that supports .NET and uploaded to the system</value>
  </data>
  <data name="CustomModule_Title" xml:space="preserve">
    <value>Custom Module</value>
  </data>
  <data name="InputTranslator_DelimiterSquence_Help" xml:space="preserve">
    <value>The Delimiter is the Character that is used to delimit your text base file this may be something like a comma, tab or a space.</value>
  </data>
  <data name="InputTranslator_DelimterSequence" xml:space="preserve">
    <value>Delimiter</value>
  </data>
  <data name="InputTranslator_Description" xml:space="preserve">
    <value>The Input Translator is used to Transform the Raw Message received from the device to a set of key value pairs that can be used within your device workflow</value>
  </data>
  <data name="InputTranslator_Help" xml:space="preserve">
    <value>The Input Translator is used to Transform the Raw Message received from the device to a set of key value pairs that can be used within your device workflow</value>
  </data>
  <data name="InputTranslator_Title" xml:space="preserve">
    <value>Input Translator</value>
  </data>
  <data name="InputTranslator_TranslatorType" xml:space="preserve">
    <value>Translator Type</value>
  </data>
  <data name="InputTranslator_TranslatorType_Select" xml:space="preserve">
    <value>-select translator type-</value>
  </data>
  <data name="Listener_AccessKey" xml:space="preserve">
    <value>Access Key</value>
  </data>
  <data name="Listener_ConnectToPort" xml:space="preserve">
    <value>Connect to Port</value>
  </data>
  <data name="Listener_DelimitedWithSOH_EOT" xml:space="preserve">
    <value>Delimited with &lt;SOH&gt; and &lt;EOT&gt;</value>
  </data>
  <data name="Listener_DelimitedWithSOH_EOT_Help" xml:space="preserve">
    <value>Select this option if the first character of the messages you are receiving start with SOH (ascii 0x01)and ended with EOT (ascii 0x04)</value>
  </data>
  <data name="Listener_Description" xml:space="preserve">
    <value>Listeners are used to Monitor a Port, Protocol or Service for Messages from your Devices</value>
  </data>
  <data name="Listener_EndMessageSequence" xml:space="preserve">
    <value>End Message Sequence</value>
  </data>
  <data name="Listener_EndMessageSequence_Help" xml:space="preserve">
    <value>The character or characters that will make up the end of your message</value>
  </data>
  <data name="Listener_Endpoint" xml:space="preserve">
    <value>Endpoint</value>
  </data>
  <data name="Listener_Help" xml:space="preserve">
    <value>Listeners are used to Monitor a Port, Protocol or Service for Messages from your Devices</value>
  </data>
  <data name="Listener_KeepAliveToSendReply" xml:space="preserve">
    <value>Keep Alive to Send Reply</value>
  </data>
  <data name="Listener_KeepAliveToSendReplyTimeout_Help" xml:space="preserve">
    <value>The amount of time to keep the Incoming Connection alive to send a reply.  If the Pipeline never sends a messages within this time frame, the connection will be Closed.</value>
  </data>
  <data name="Listener_KeepAliveToSendReply_Timeout" xml:space="preserve">
    <value>Keep Alive Timeout (MS)</value>
  </data>
  <data name="Listener_Length_Endiness" xml:space="preserve">
    <value>Message Length Endiness</value>
  </data>
  <data name="Listener_Length_Endiness_Help" xml:space="preserve">
    <value>What is the Endiness of the bytes that make up the lengh of the message.</value>
  </data>
  <data name="Listener_Length_Endiness_Select" xml:space="preserve">
    <value>-select message length endiness-</value>
  </data>
  <data name="Listener_Length_Location" xml:space="preserve">
    <value>Length Location</value>
  </data>
  <data name="Listener_Length_LocationByteLength" xml:space="preserve">
    <value>Message Length Bytes</value>
  </data>
  <data name="Listener_Length_LocationByteLength_Help" xml:space="preserve">
    <value>How many bytes make up the length of the message.</value>
  </data>
  <data name="Listener_Length_Location_Help" xml:space="preserve">
    <value>If your message has a byte or set of bytes that contain the length of the message, where are they with respect to the zero indexed first byte.</value>
  </data>
  <data name="Listener_ListenerType" xml:space="preserve">
    <value>Listener Type</value>
  </data>
  <data name="Listener_ListenOnPort" xml:space="preserve">
    <value>Listen on Port</value>
  </data>
  <data name="Listener_MaxMessageSize" xml:space="preserve">
    <value>Max Message Size</value>
  </data>
  <data name="Listener_MaxMessageSize_Help" xml:space="preserve">
    <value>The Maximum Size in Bytes of your Message, this is used to allocate memory and check for buffer overflows.</value>
  </data>
  <data name="Listener_MessageContainsLength" xml:space="preserve">
    <value>Messge Contains Length Information</value>
  </data>
  <data name="Listener_MessageContainsLength_Help" xml:space="preserve">
    <value>The message it self contains a byte or series of bytes that contains the length of the entire message.</value>
  </data>
  <data name="Listener_MessageLength_1_Byte" xml:space="preserve">
    <value>1 Byte</value>
  </data>
  <data name="Listener_MessageLength_2_Bytes" xml:space="preserve">
    <value>2 Bytes</value>
  </data>
  <data name="Listener_MessageLength_4_Bytes" xml:space="preserve">
    <value>4 Bytes</value>
  </data>
  <data name="Listener_MessageLength_Select" xml:space="preserve">
    <value>-select message length byte count-</value>
  </data>
  <data name="Listener_MessageReceivedTimeout" xml:space="preserve">
    <value>Message Received Timeout (MS)</value>
  </data>
  <data name="Listener_MessageReceivedTimeout_Help" xml:space="preserve">
    <value>Number of Millieseconds from when the First Byte of your Message Arives until it is expected that the entire message will be received.  If the entire message is not received within this time period, the receive function will be aborted.</value>
  </data>
  <data name="Listener_Password" xml:space="preserve">
    <value>Password</value>
  </data>
  <data name="Listener_Port_Help" xml:space="preserve">
    <value>If your listener will listen on a Socket Provide the port it wil listen on.</value>
  </data>
  <data name="Listener_StartMessageSequence" xml:space="preserve">
    <value>Start Message Sequence</value>
  </data>
  <data name="Listener_StartMessageSequence_Help" xml:space="preserve">
    <value>The character or characters that will make up the beginning of your message.</value>
  </data>
  <data name="Listener_Subscription" xml:space="preserve">
    <value>Subscription</value>
  </data>
  <data name="Listener_Title" xml:space="preserve">
    <value>Listener</value>
  </data>
  <data name="Listener_Topic" xml:space="preserve">
    <value>Topic</value>
  </data>
  <data name="Listener_UserName" xml:space="preserve">
    <value>User Name</value>
  </data>
  <data name="MessageFieldParseConfiguration_BinaryOffset_Help" xml:space="preserve">
    <value>Enter the start location in the byte array that contains the value you wish to extract.</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryOffset" xml:space="preserve">
    <value>Offset</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType" xml:space="preserve">
    <value>Binary Data Type</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Boolean" xml:space="preserve">
    <value>Boolean</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Char" xml:space="preserve">
    <value>Char</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_DoublePrecisionFloatingPoint" xml:space="preserve">
    <value>Double Precision Floating Point</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int16BigEndian" xml:space="preserve">
    <value>Signed 16 Bit Integer (big endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int16LittleEndian" xml:space="preserve">
    <value>Signed 16 Bit Integer (little endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int32BigEndian" xml:space="preserve">
    <value>Signed 32 Bit Integer (big endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int32LittleEndian" xml:space="preserve">
    <value>Signed 32 Bit Integer (little endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int64BigEndian" xml:space="preserve">
    <value>Signed 64 Bit Integer (big endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int64LittleEndian" xml:space="preserve">
    <value>Signed 64 Bit Integer (little endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_Int8" xml:space="preserve">
    <value>Signed 8 Bit Integer</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_SelectDataType" xml:space="preserve">
    <value>-select data type-</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_SelectDataType_Help" xml:space="preserve">
    <value>Select the data type that represents the value to be extracted from the field</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_SinglePrecisionFloatingPoint" xml:space="preserve">
    <value>Single Precision Floating Point</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_String" xml:space="preserve">
    <value>String</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt16BigEndian" xml:space="preserve">
    <value>Unsigned 16 Bit Integer (big endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt16LittleEndian" xml:space="preserve">
    <value>Unsigned 16 Bit Integer (little endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt32BigEndian" xml:space="preserve">
    <value>Unsigned 32 Bit Integer (big endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt32LittleEndian" xml:space="preserve">
    <value>Unsigned 32 Bit Integer (little endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt64BigEndian" xml:space="preserve">
    <value>Unsigned 64 Bit Integer (big endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt64LittleEndian" xml:space="preserve">
    <value>Unsigned 64 Bit Integer (little endian)</value>
  </data>
  <data name="MessageFieldParserConfiguration_BinaryType_UInt8" xml:space="preserve">
    <value>Unsigned 8 Bit Integer</value>
  </data>
  <data name="MessageFieldParserConfiguration_DelimitedColumnIndex" xml:space="preserve">
    <value>Delimited Column Index</value>
  </data>
  <data name="MessageFieldParserConfiguration_DelimitedColumnIndex_Help" xml:space="preserve">
    <value>If you are working with a Delimited string, you can specify the index into the delimted values where the value shoudl be extracted.</value>
  </data>
  <data name="MessageFieldParserConfiguration_Delimiter" xml:space="preserve">
    <value>Delimiter</value>
  </data>
  <data name="MessageFieldParserConfiguration_Delimitor_Help" xml:space="preserve">
    <value>This is the character that will be used to Delimit your text, this will usually be something like , for a CSV or sometimes a Tab (\t).  The Delimiter will only except a single character unless you are escaping your character such as \t.</value>
  </data>
  <data name="MessageFieldParserConfiguration_Description" xml:space="preserve">
    <value>Allows for Parsing the Message or Message Envelope to Extract a Field or Fields</value>
  </data>
  <data name="MessageFieldParserConfiguration_Help" xml:space="preserve">
    <value>Allows for Parsing the Message or Message Envelope to Extract a Field or Fields</value>
  </data>
  <data name="MessageFieldParserConfiguration_KeyName" xml:space="preserve">
    <value>Key Name</value>
  </data>
  <data name="MessageFieldParserConfiguration_KeyName_Help" xml:space="preserve">
    <value>The Key Name is used to extract values from headers, JSON or XML input.  For example if the name of your header is "DeviceID", the Key Name to extract that value will be "DeviceID" if your JSON contains a property such as {'value1':{'subvalue1':5}}  The key name value1.subvalue1 will extract the value 5.</value>
  </data>
  <data name="MessageFieldParserConfiguration_Length" xml:space="preserve">
    <value>Length</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType" xml:space="preserve">
    <value>Output Data Type</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType_Boolean" xml:space="preserve">
    <value>Boolean</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType_FloatingPoint" xml:space="preserve">
    <value>Floating Point</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType_Integer" xml:space="preserve">
    <value>Integer</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType_SelectDataType" xml:space="preserve">
    <value>-select output data type-</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType_SelectDataType_Help" xml:space="preserve">
    <value>Select the data type that the parsed value will be stored.</value>
  </data>
  <data name="MessageFieldParserConfiguration_OutputType_String" xml:space="preserve">
    <value>String</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy" xml:space="preserve">
    <value>Parser Strategy</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Delimited" xml:space="preserve">
    <value>Delimited</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Header" xml:space="preserve">
    <value>Value in Header</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Help" xml:space="preserve">
    <value>You have differnt options as to how you can extract values from your message, please choose one of these options.</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_JsonProperty" xml:space="preserve">
    <value>JSON Property</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_PathLocator" xml:space="preserve">
    <value>Path Locator</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_PathLocator_Help" xml:space="preserve">
    <value>If the Device ID or Message Type Id Arrives in the path it can be extract using the syntax /api/{messageid}/*.  This will extract msg001 from /api/msg001/52345.  The value messageid is specified in the Key Name and can be used to extract either a Message Type Id or a Device Id.</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Position" xml:space="preserve">
    <value>Position</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_QueryString" xml:space="preserve">
    <value>Query String</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_QueryStringField" xml:space="preserve">
    <value>Query String Field</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_QueryStringField_Help" xml:space="preserve">
    <value>You can extract a field from the query string by providing the name of the field. For example, the query string field "deviceid" will extract "abc123" from /path/device/run?deviceid=abc123</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_RegEx" xml:space="preserve">
    <value>Regular Expression</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_RegExHeader" xml:space="preserve">
    <value>Header Value with Regular Expression</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_RegExHeader_Help" xml:space="preserve">
    <value>This option will allow you to use a Regular Expression extract a value from the Message Envelope Property Bag</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Select" xml:space="preserve">
    <value>-select parser strategy-</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_Substring" xml:space="preserve">
    <value>Substring</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_URIPath" xml:space="preserve">
    <value>URI Path</value>
  </data>
  <data name="MessageFieldParserConfiguration_ParserStrategy_XMLProperty" xml:space="preserve">
    <value>XML Property</value>
  </data>
  <data name="MessageFieldParserConfiguration_QuotedText" xml:space="preserve">
    <value>Quoted Text</value>
  </data>
  <data name="MessageFieldParserConfiguration_QuotedText_Help" xml:space="preserve">
    <value>Sets the parser to expect that the string contained in your delimited input has quote around strings.  If so the parser will look for strings enclosed in " (quotes) or ' (ticks) and escape those characters within the string if appropriate. If this is not set, any quotes in your delimited input will be included in the returned value.</value>
  </data>
  <data name="MessageFieldParserConfiguration_RegExGroupName" xml:space="preserve">
    <value>Regular Expression Group Name</value>
  </data>
  <data name="MessageFieldParserConfiguration_RegExGroupName_Help" xml:space="preserve">
    <value>When you add a Regular Expression Locator you need to specify a Group Name as part of the Regular Expression.  To locate that result in your Regular Expression Match, add the Group Name Here.  For Example with the Regular expression [^\\$(?'DeviceId'[\\w]{3,10}),]  the grouop name that will be extracted with be DeviceId.</value>
  </data>
  <data name="MessageFieldParserConfiguration_RegExLocator" xml:space="preserve">
    <value>Regular Expression Locator</value>
  </data>
  <data name="MessageFieldParserConfiguration_RegExLocator_Help" xml:space="preserve">
    <value>Add a Regular Expression with a Group Identifier to Locate your Field.  You will also need to add the Group Identifier that you specified</value>
  </data>
  <data name="MessageFieldParserConfiguration_RegExValidation" xml:space="preserve">
    <value>Regular Expression Validation</value>
  </data>
  <data name="MessageFieldParserConfiguration_RegExValidation_Help" xml:space="preserve">
    <value>For any of the Parser Types, you can add a second check in the form of a Regular Expression to validate the field that was found was indeed the correct value you were looking for</value>
  </data>
  <data name="MessageFieldParserConfiguration_StartIndex" xml:space="preserve">
    <value>Start Index (1 Index)</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParserType" xml:space="preserve">
    <value>String Parsing Type</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParserType_Help" xml:space="preserve">
    <value>Select the strategy for parsing a string from your message, you can select a null terminated string or a the string length will be the first characters of your string.</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParserType_LeadingLength" xml:space="preserve">
    <value>Prefixed with Length</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParserType_NullTerminated" xml:space="preserve">
    <value>Null Terminated</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParserType_Select" xml:space="preserve">
    <value>-select string parsing type-</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParser_NumberBytes" xml:space="preserve">
    <value>String Parsing Length Bytes</value>
  </data>
  <data name="MessageFieldParserConfiguration_StringParser_NumberBytes_Help" xml:space="preserve">
    <value>Specify the number of Bytes that will be used to describe the length of your string.</value>
  </data>
  <data name="MessageFieldParserConfiguration_SubString_Help" xml:space="preserve">
    <value>If the value you are looking for is always in the same location within your string you can extract it by providing the Start Index and an Length. Note that the start index is 1 Indexed, that is to say if you want the first character the start index will be 1, You should never enter 0 in this field.</value>
  </data>
  <data name="MessageFieldParserConfiguration_Title" xml:space="preserve">
    <value>Message Field Parser</value>
  </data>
  <data name="MessageFieldParserConfiguration_ValueName" xml:space="preserve">
    <value>Value Name</value>
  </data>
  <data name="MessageFieldParserConfiguration_ValueName_Help" xml:space="preserve">
    <value>If you are building up a list of parsed properties from your message, you can provide the Value Name that will be associated with the value here.  For Example if you are parsing a value within your message that is associated with a Speed that is measured your Value Name might make sense to be Speed</value>
  </data>
  <data name="MessageFieldParserConfiguration_XPath" xml:space="preserve">
    <value>XPath</value>
  </data>
  <data name="MessageFieldParserConfiguration_XPath_Help" xml:space="preserve">
    <value>You can define and XPath Expression to Extra a value from an XML Document</value>
  </data>
  <data name="OutputTranslator_Description" xml:space="preserve">
    <value>The Output Translator is used to Transform the Key Value Pairs that are created as part of the Workflow to the format the device is expecting so they can be sent down to the device.</value>
  </data>
  <data name="OutputTranslator_Help" xml:space="preserve">
    <value>The Output Translator is used to Transform the Key Value Pairs that are created as part of the Workflow to the format the device is expecting so they can be sent down to the device.</value>
  </data>
  <data name="OutputTranslator_Title" xml:space="preserve">
    <value>Output Translator</value>
  </data>
  <data name="OutputTranslator_TranslatorType" xml:space="preserve">
    <value>Translator Type</value>
  </data>
  <data name="OutputTranslator_TranslatorType_Select" xml:space="preserve">
    <value>-select output translator-</value>
  </data>
  <data name="Planner_Description" xml:space="preserve">
    <value>The Planner is used to identify the device that sent the message as well as the specific message that is being sent.  Based on those two peices of information, the Device Configuration can be used to create plan from the Route for that specific message as to how the message should be processed.</value>
  </data>
  <data name="Planner_DeviceIDParsers" xml:space="preserve">
    <value>Device ID Parsers</value>
  </data>
  <data name="Planner_DeviceIDParsers_Help" xml:space="preserve">
    <value>Your Planner will be provided the raw message information as well as the message envlope headers.  It is the Planners job to Extract the Device ID and Optionally a Message Type Id so it can be mapped to a Device Configuration. 

This is a list of parsers that are executed in the order they appear, if a match is not found with one parser, the next one is executed.  Once the first value response is identified, it will no longer search for additional matches.</value>
  </data>
  <data name="Planner_Help" xml:space="preserve">
    <value>The Planner is used to identify the device that sent the message as well as the specific message that is being sent.  Based on those two peices of information, the Device Configuration can be used to create plan from the Route for that specific message as to how the message should be processed.</value>
  </data>
  <data name="Planner_MessageTypeIDParsers" xml:space="preserve">
    <value>Message Type ID Parsers</value>
  </data>
  <data name="Planner_MessageTypeIDParsers_Help" xml:space="preserve">
    <value>Your Planner will be provided the raw message information as well as the message envlope headers.  It is the Planners job to Extract the Device ID and Optionally a Message Type Id so it can be mapped to a Device Configuration. 

This is a list of parsers that are executed in the order they appear, if a match is not found with one parser, the next one is executed.  Once the first value response is identified, it will no longer search for additional matches.</value>
  </data>
  <data name="Planner_PipelineModules" xml:space="preserve">
    <value>Work Plan</value>
  </data>
  <data name="Planner_Title" xml:space="preserve">
    <value>Planner</value>
  </data>
  <data name="Sentinel_Description" xml:space="preserve">
    <value>The Sential Module provides security for your Device.  It will authenticate that the device that is sending the message is that which is claimed.</value>
  </data>
  <data name="Sentinel_Help" xml:space="preserve">
    <value>The Sential Module provides security for your Device.  It will authenticate that the device that is sending the message is that which is claimed.</value>
  </data>
  <data name="Sentinel_Title" xml:space="preserve">
    <value>Sentinel</value>
  </data>
  <data name="Translator_Type_Binary" xml:space="preserve">
    <value>Binary</value>
  </data>
  <data name="Translator_Type_Custom" xml:space="preserve">
    <value>Custom</value>
  </data>
  <data name="Translator_Type_Delimited" xml:space="preserve">
    <value>Delimited</value>
  </data>
  <data name="Translator_Type_JSON" xml:space="preserve">
    <value>JSON</value>
  </data>
  <data name="Translator_Type_String" xml:space="preserve">
    <value>String</value>
  </data>
  <data name="Translator_Type_XML" xml:space="preserve">
    <value>XML</value>
  </data>
  <data name="Transmitter_Description" xml:space="preserve">
    <value>The Transmitter is used to send messages back to the device.</value>
  </data>
  <data name="Transmitter_Help" xml:space="preserve">
    <value>The Transmitter is used to send messages back to the device.</value>
  </data>
  <data name="Transmitter_Title" xml:space="preserve">
    <value>Transmitter</value>
  </data>
  <data name="Transmitter_TransmitterType" xml:space="preserve">
    <value>Transmitter Type</value>
  </data>
  <data name="Transmitter_TransmitterType_OriginalListener" xml:space="preserve">
    <value>Original Listener</value>
  </data>
  <data name="Transmitter_TransmitterType_Outbox" xml:space="preserve">
    <value>Outbox</value>
  </data>
  <data name="Transmitter_TransmitterType_SMS" xml:space="preserve">
    <value>SMS</value>
  </data>
  <data name="Transmitter_TransmitterType_SMTP" xml:space="preserve">
    <value>SMTP</value>
  </data>
  <data name="Translator_Type_Message" xml:space="preserve">
    <value>Message Based</value>
  </data>
  <data name="PipelineModuleType_Custom" xml:space="preserve">
    <value>Custom</value>
  </data>
  <data name="PipelineModuleType_InputTranslator" xml:space="preserve">
    <value>Input Translator</value>
  </data>
  <data name="PipelineModuleType_Listener" xml:space="preserve">
    <value>Listener</value>
  </data>
  <data name="PipelineModuleType_OutputTranslator" xml:space="preserve">
    <value>Output Translator</value>
  </data>
  <data name="PipelineModuleType_Planner" xml:space="preserve">
    <value>Planner</value>
  </data>
  <data name="PipelineModuleType_Sentinel" xml:space="preserve">
    <value>Sentinel</value>
  </data>
  <data name="PipelineModuleType_Transmitter" xml:space="preserve">
    <value>Transmitter</value>
  </data>
  <data name="PipelineModuleType_Workflow" xml:space="preserve">
    <value>Workflow</value>
  </data>
  <data name="Err_CouldNotLoadInputTranslator" xml:space="preserve">
    <value>Could Not Find Input Translator</value>
  </data>
  <data name="Err_CouldNotLoadListener" xml:space="preserve">
    <value>Could Not Find Listener</value>
  </data>
  <data name="Err_CouldNotLoadOutputTranslator" xml:space="preserve">
    <value>Could Not Load Output Translator</value>
  </data>
  <data name="Err_CouldNotLoadPlanner" xml:space="preserve">
    <value>Could Not Load Planner</value>
  </data>
  <data name="Err_CouldNotLoadSentinel" xml:space="preserve">
    <value>Could Not Load Sentinel</value>
  </data>
  <data name="Err_CouldNotLoadTransmitter" xml:space="preserve">
    <value>Could Not Load Transmitter</value>
  </data>
  <data name="Err_CouldNotLoadCustomModule" xml:space="preserve">
    <value>Could Not Find Custom Module</value>
  </data>
  <data name="Connection_Type_MQTT_Client" xml:space="preserve">
    <value>MQTT Client</value>
  </data>
  <data name="Listener_ResourceName" xml:space="preserve">
    <value>Resource Name</value>
  </data>
  <data name="Listener_EventHub_ConsumerGroup" xml:space="preserve">
    <value>Consumer Group</value>
  </data>
  <data name="ConnectionType_MQTT_Listener" xml:space="preserve">
    <value>MQTT Listener (low volume/dev)</value>
  </data>
  <data name="ConnectionType_RabbitMQ" xml:space="preserve">
    <value>RabbitMQ</value>
  </data>
  <data name="ConnectionType_RabbitMQClient" xml:space="preserve">
    <value>RabbitMQ Client</value>
  </data>
  <data name="Listener_AccessKeyName" xml:space="preserve">
    <value>Access Key Name</value>
  </data>
  <data name="Listener_HostName" xml:space="preserve">
    <value>Host Name</value>
  </data>
  <data name="Listener_Anonymous" xml:space="preserve">
    <value>Anonymous Connection</value>
  </data>
  <data name="Listener_ConnectSSLTLS" xml:space="preserve">
    <value>Connect with SSL/TLS</value>
  </data>
  <data name="Listener_Queue" xml:space="preserve">
    <value>Queue</value>
  </data>
  <data name="Listener_HubName" xml:space="preserve">
    <value>Hub Name</value>
  </data>
  <data name="Transmitter_Headers" xml:space="preserve">
    <value>Headers</value>
  </data>
  <data name="Err_TransmitterTypeIsRequired" xml:space="preserve">
    <value>Transmitter Type is Required</value>
  </data>
  <data name="Listener_Subscriptions" xml:space="preserve">
    <value>Subscriptions</value>
  </data>
  <data name="Listener_AccessKeyName_Help" xml:space="preserve">
    <value>Please provide the name of the Access Key or Shared Access Policy for the provided Access Key, ensure this access key has the proper claims to access the resource.  See the associated help for required claims.</value>
  </data>
  <data name="Listener_AccessKey_Help" xml:space="preserve">
    <value>Please provide the Access Key that has proper permission to access this server resource.  The Access Key is a Base 64 Encoded value such as f9/XxrkJ84bnH+z7+5tTbHbANhYtqo1E4vryLtpoyUc= </value>
  </data>
  <data name="Listener_ConsumerGroup_Help" xml:space="preserve">
    <value>Please provide the Consumer Group for this event hub, if you leave this blank your listener will use the $Default Consumer Group.</value>
  </data>
  <data name="Listener_HubName_Help" xml:space="preserve">
    <value>Please provide the name of the Event Hub resource for this connection.</value>
  </data>
  <data name="Listener_Password_Help" xml:space="preserve">
    <value>Please provide a Password to allow access to this resource.</value>
  </data>
  <data name="Listener_Queue_Help" xml:space="preserve">
    <value>Please provide the name of the Queue resource for this connection.</value>
  </data>
  <data name="Listener_RESTServerType" xml:space="preserve">
    <value>Allowable Connection Type</value>
  </data>
  <data name="Listener_RESTServerType_HTTP" xml:space="preserve">
    <value>HTTP</value>
  </data>
  <data name="Listener_RESTServerType_HTTPorHTTPS" xml:space="preserve">
    <value>HTTP or HTTPS</value>
  </data>
  <data name="Listener_RESTServerType_HTTPS" xml:space="preserve">
    <value>HTTPS</value>
  </data>
  <data name="Listener_RESTServerType_Select" xml:space="preserve">
    <value>-select connection type-</value>
  </data>
  <data name="Listener_UserName_Help" xml:space="preserve">
    <value>Please provide a User Name to allow access to this resource.</value>
  </data>
  <data name="Connection_Type_WebSocket" xml:space="preserve">
    <value>Web Socket</value>
  </data>
  <data name="Listener_Origin" xml:space="preserve">
    <value>Origin</value>
  </data>
  <data name="Listener_Path" xml:space="preserve">
    <value>Path</value>
  </data>
  <data name="Listener_SupportedProtocol" xml:space="preserve">
    <value>Supported Protocol</value>
  </data>
  <data name="Sentinel_SecurityField" xml:space="preserve">
    <value>Security Fields</value>
  </data>
  <data name="Sentinel_SecurityField_Help" xml:space="preserve">
    <value>You can define a set of security field definitions that will be used to look in the message to find a value that can be used to authenticate your message.  </value>
  </data>
  <data name="Sentinel_SecurityField_Locator" xml:space="preserve">
    <value>Locators</value>
  </data>
  <data name="Sentinel_SecurityField_Locator_Help" xml:space="preserve">
    <value>Locators are used to locate the item within the incoming message that will be used to authenticate the device sending the message.</value>
  </data>
  <data name="Sentinel_SecurityField_Title" xml:space="preserve">
    <value>Security Field</value>
  </data>
  <data name="Sentinel_SecurityField_Description" xml:space="preserve">
    <value>Security Fields are used to describe where authentication information should arrive in your device messages as well as how that information should be validated.</value>
  </data>
  <data name="Sentinel_SecurityField_Title_Help" xml:space="preserve">
    <value>Security Fields are used to describe where authentication information should arrive in your device messages as well as how that information should be validated. </value>
  </data>
  <data name="Sentinel_SecurityField_Type" xml:space="preserve">
    <value>Authentication Type</value>
  </data>
  <data name="Sentinel_SecurityField_Type_Help" xml:space="preserve">
    <value>You can define different methods on how the authentication value should be used to authenticate messages coming from your devices.</value>
  </data>
  <data name="Sentinel_SecurityField_Type_AccessKey" xml:space="preserve">
    <value>Access Key</value>
  </data>
  <data name="Sentinel_SecurityField_Type_BasicAuth" xml:space="preserve">
    <value>Basic Access Authentication</value>
  </data>
  <data name="Sentinel_SecurityField_Type_Select" xml:space="preserve">
    <value>-select authentication scheme-</value>
  </data>
  <data name="Sentinel_SecurityField_Type_SharedSignature" xml:space="preserve">
    <value>Shared Signature</value>
  </data>
  <data name="Common_UniqueId" xml:space="preserve">
    <value>Record Id</value>
  </data>
  <data name="Sentinel_SecurityField_Type_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="Sentinel_SecurityField_Locator_Select" xml:space="preserve">
    <value>-select field locator-</value>
  </data>
  <data name="Connection_Type_SharedRest" xml:space="preserve">
    <value>Shared REST</value>
  </data>
  <data name="PipelineModuleType_DataStream" xml:space="preserve">
    <value>Data Stream</value>
  </data>
  <data name="DataStreamField_DataType" xml:space="preserve">
    <value>Data Type</value>
  </data>
  <data name="DataStreamField_DataType_Help" xml:space="preserve">
    <value>Provide the type of data that will be inserted into the column.</value>
  </data>
  <data name="DataStreamField_DataType_Select" xml:space="preserve">
    <value>-select data type-</value>
  </data>
  <data name="DataStreamField_Description" xml:space="preserve">
    <value>A data stream value defines a field that will be used as a data point within a data stream.</value>
  </data>
  <data name="DataStreamField_FieldName" xml:space="preserve">
    <value>Field Name</value>
  </data>
  <data name="DataStreamField_FieldName_Help" xml:space="preserve">
    <value>The field name will be how the field will be identified in the output, this can be the name of the database column or the name of a JSON property</value>
  </data>
  <data name="DataStreamField_Help" xml:space="preserve">
    <value>A data stream value defines a field that will be used as a data point within a data stream.</value>
  </data>
  <data name="DataStreamField_IsRequired" xml:space="preserve">
    <value>Is Required</value>
  </data>
  <data name="DataStreamField_IsRequired_Help" xml:space="preserve">
    <value>If you specify the field as being required and it is not present the record will not be inserted into the data stream.</value>
  </data>
  <data name="DataStreamField_MaxValue" xml:space="preserve">
    <value>Maximum Value</value>
  </data>
  <data name="DataStreamField_MaxValue_Help" xml:space="preserve">
    <value>Provide an optional maximum value used for validation.</value>
  </data>
  <data name="DataStreamField_MinValue" xml:space="preserve">
    <value>Minimum Value</value>
  </data>
  <data name="DataStreamField_MinValue_Help" xml:space="preserve">
    <value>Provide an optional minimum value used for validation.</value>
  </data>
  <data name="DataStreamField_NumberDecimalPoints" xml:space="preserve">
    <value>Decimal Points</value>
  </data>
  <data name="DataStreamField_NumberDecimalPoints_Help" xml:space="preserve">
    <value>Provide a number of decimal places that the field should be formatted with</value>
  </data>
  <data name="DataStreamField_RegEx" xml:space="preserve">
    <value>Reg Ex Validation</value>
  </data>
  <data name="DataStreamField_RegEx_Help" xml:space="preserve">
    <value>Provide a regular expression used for validating the content of the field.</value>
  </data>
  <data name="DataStreamField_StateSet" xml:space="preserve">
    <value>State Set</value>
  </data>
  <data name="DataStreamField_StateSet_Watermark" xml:space="preserve">
    <value>-select state set-</value>
  </data>
  <data name="DataStreamField_Title" xml:space="preserve">
    <value>Data Stream Field</value>
  </data>
  <data name="DataStreamField_UnitSet" xml:space="preserve">
    <value>Unit Set</value>
  </data>
  <data name="DataStreamField_UnitSet_Watermark" xml:space="preserve">
    <value>-select unit set-</value>
  </data>
  <data name="DataStream_ConnectionString" xml:space="preserve">
    <value>Connection String</value>
  </data>
  <data name="DataStream_ConnectionString_Help" xml:space="preserve">
    <value>If your data stream storage is not managed by NuvIoT, you will need to provide a connection string to your storage resource.  This storage string will not be stored in plain text.</value>
  </data>
  <data name="DataStream_Description" xml:space="preserve">
    <value>A Data Stream is a predefined set of fields that can be used to produce time series data that can be then used by other analysis tools or machine learning algorithms.</value>
  </data>
  <data name="DataStream_Fields" xml:space="preserve">
    <value>Fields</value>
  </data>
  <data name="DataStream_Help" xml:space="preserve">
    <value>A Data Stream is a predefined set of fields that can be used to produce time series data that can be then used by other analysis tools or machine learning algorithms.</value>
  </data>
  <data name="DataStream_StreamType" xml:space="preserve">
    <value>Stream Type</value>
  </data>
  <data name="DataStream_StreamType_AWS_ElasticSearch" xml:space="preserve">
    <value>AWS Elastic Search</value>
  </data>
  <data name="DataStream_StreamType_AWS_S3" xml:space="preserve">
    <value>AWS S3</value>
  </data>
  <data name="DataStream_StreamType_AzureBlob" xml:space="preserve">
    <value>Azure Blob Storage</value>
  </data>
  <data name="DataStream_StreamType_AzureBlob_Managed" xml:space="preserve">
    <value>Managed Azure Blob Storage</value>
  </data>
  <data name="DataStream_StreamType_AzureEventHub" xml:space="preserve">
    <value>Azure Event Hub</value>
  </data>
  <data name="DataStream_StreamType_AzureEventHub_Managegd" xml:space="preserve">
    <value>Managed Azure Event Hub</value>
  </data>
  <data name="DataStream_StreamType_DataLake" xml:space="preserve">
    <value>Azure Data Lake</value>
  </data>
  <data name="DataStream_StreamType_Select" xml:space="preserve">
    <value>-select stream type-</value>
  </data>
  <data name="DataStream_StreamType_SQLServer" xml:space="preserve">
    <value>SQL Server</value>
  </data>
  <data name="DataStream_StreamType_TableStorage" xml:space="preserve">
    <value>Azure Table Storage</value>
  </data>
  <data name="DataStream_StreamType_TableStorage_Managed" xml:space="preserve">
    <value>Built In Data Stream Storage</value>
  </data>
  <data name="DataStream_Title" xml:space="preserve">
    <value>Data Stream</value>
  </data>
  <data name="Err_CouldNotLoadDataStream" xml:space="preserve">
    <value>Could not load data stream configuration.</value>
  </data>
  <data name="DataStream_AutoCreateTable" xml:space="preserve">
    <value>Auto Create SQL Server Table</value>
  </data>
  <data name="DataStream_AutoCreateTable_Help" xml:space="preserve">
    <value>If you choose this option the connection string you provide must allow access to modify your databases table structure. This is not recommended.</value>
  </data>
  <data name="DataStream_AWSAccessKey" xml:space="preserve">
    <value>AWS Access Key</value>
  </data>
  <data name="DataStream_AWSRegion" xml:space="preserve">
    <value>AWS Region</value>
  </data>
  <data name="DataStream_AWSSecretKey" xml:space="preserve">
    <value>AWS Secret Key</value>
  </data>
  <data name="DataStream_DateStorageFormat" xml:space="preserve">
    <value>Date Storage Format</value>
  </data>
  <data name="DataStream_DateStorageFormat_Help" xml:space="preserve">
    <value>You can store the date as a numeric seconds since epoch (1/1/1970) or ISO8601 Format (YYYY-MM-DDTHH:MM:SS.mmmm)</value>
  </data>
  <data name="DataStream_DateStorageFormat_Select" xml:space="preserve">
    <value>-select date storage format-</value>
  </data>
  <data name="DataStream_DateStorageFormat_Type_Epoch" xml:space="preserve">
    <value>Unix Epoch</value>
  </data>
  <data name="DataStream_DateStorageFormat_Type_ISO8601" xml:space="preserve">
    <value>IS0 8601 (YYYY-MM-DDTHH:MM:SS.mmmm)</value>
  </data>
  <data name="DataStream_DeviceIdFieldName" xml:space="preserve">
    <value>Device Id Field Name</value>
  </data>
  <data name="DataStream_DeviceIdFieldName_Help" xml:space="preserve">
    <value>The Device Id Field Name is the name of the column in the datbase or the JSON property that is associated with the device that generated the values for the data stream.</value>
  </data>
  <data name="DataStream_InvalidBucketName" xml:space="preserve">
    <value>Invalid name for S3 bucket, please check AWS documentation results for valid bucket names.</value>
  </data>
  <data name="DataStream_InvalidTableName" xml:space="preserve">
    <value>Invalid table name, please check an online reference for your database server.</value>
  </data>
  <data name="DataStream_S3_BucketName" xml:space="preserve">
    <value>S3 Bucket Name</value>
  </data>
  <data name="DataStream_TableName" xml:space="preserve">
    <value>Database Table Name</value>
  </data>
  <data name="DataStream_TimeStampFieldName" xml:space="preserve">
    <value>Time Stamp Field Name</value>
  </data>
  <data name="DataStream_TimeStampFieldName_Help" xml:space="preserve">
    <value>The Time Stamp Field Name is the name of the column in a database or the JSON property that is associated with the time stamp for the data stream record.</value>
  </data>
  <data name="DataStream_AWSSecretKey_Help" xml:space="preserve">
    <value>Enter your AWS Secret key, this is required for creating a new data stream and will be encrypted at rest.  When you edit your data stream your original secret key will not be displayed, however if you enter a new one, the original one will be replaced.</value>
  </data>
  <data name="DataStream_AzureAccessKey" xml:space="preserve">
    <value>Azure Access Key</value>
  </data>
  <data name="DataStream_AzureAccessKeyHelp" xml:space="preserve">
    <value>Enter your Azure Access key, this is required for creating a new data stream and will be encrypted at rest.  When you edit your data stream your original access key will not be displayed, however if you enter a new one, the original one will be replaced.</value>
  </data>
  <data name="DataStream_AzureAccountId" xml:space="preserve">
    <value>Azure Account Id</value>
  </data>
  <data name="DataStream_AzureEventHubName" xml:space="preserve">
    <value>Azure Event Hub Name</value>
  </data>
  <data name="DataStream_AzureEventHubPath" xml:space="preserve">
    <value>Azure Event Hub Entity Path</value>
  </data>
  <data name="DataStream_BlobStoragePath" xml:space="preserve">
    <value>Blob Container Name</value>
  </data>
  <data name="DataStream_DbName" xml:space="preserve">
    <value>Database Name</value>
  </data>
  <data name="DataStream_DbPassword" xml:space="preserve">
    <value>Database Password</value>
  </data>
  <data name="DataStream_DbPassword_Help" xml:space="preserve">
    <value>Enter your databases password, this is required for creating a new data stream and will be encrypted at rest.  When you edit your data stream your original password will not be displayed, however if you enter a new one, the original one will be replaced.</value>
  </data>
  <data name="DataStream_DbURL" xml:space="preserve">
    <value>Database Url</value>
  </data>
  <data name="DataStream_DbUserName" xml:space="preserve">
    <value>Database User Name</value>
  </data>
  <data name="DataStream_DbValidateSchema" xml:space="preserve">
    <value>Validate Schema</value>
  </data>
  <data name="DataStream_DbValidateSchema_Help" xml:space="preserve">
    <value>Valdating the scema will ensure that the fields, time stamp field and device id field are compatible with your database, however it requires the user name you provided has additional privelages</value>
  </data>
  <data name="DataStream_ESDomainName" xml:space="preserve">
    <value>Elastic Search Domain Name</value>
  </data>
  <data name="DataStream_ESIndexName" xml:space="preserve">
    <value>Elastic Search Index Name</value>
  </data>
  <data name="DataStream_ESTypeName" xml:space="preserve">
    <value>Elastic Search Data Type Name</value>
  </data>
  <data name="DataStream_TableStorageName" xml:space="preserve">
    <value>Table Storage Name</value>
  </data>
  <data name="DataStream_ESDomainName_Invalid" xml:space="preserve">
    <value>Invalid Elastic Search Domain Name, Domain name must be between 3 and 64 characters, must start with a letter and include only lower case letters and numbers and a hypen (-)</value>
  </data>
  <data name="DataStream_ESIndexName_Invalid" xml:space="preserve">
    <value>Invalid Elastic Search Index Name, please see AWS documentation for index names.</value>
  </data>
  <data name="DataStream_ESTypeNameInvalid" xml:space="preserve">
    <value>Invalid Elastic Seach Type Name, please see AWS documentation for valid type names.</value>
  </data>
  <data name="DataStream_DbUrl_InvalidUrl" xml:space="preserve">
    <value>URL of database server is an invalid URL.</value>
  </data>
  <data name="DataStream_InvalidEHName" xml:space="preserve">
    <value>The event hub name must be between 6 and 50 characters and can contain only letters, numbers, periods, hyphens and underscores. The name must start and end with a letter or number.</value>
  </data>
  <data name="DataStream_InvalidEHPathName" xml:space="preserve">
    <value>The event hub entity path name can contain only letters, numbers, periods, hyphens and underscores. The name must start and end with a letter or number.</value>
  </data>
  <data name="DataStream_TableStorage_InvalidName" xml:space="preserve">
    <value>Invalid table storage name, your name must contain only upper and lower case letters and numbers and be between 3 and 63 characters.</value>
  </data>
  <data name="DataStream_BlobStorage_InvalidName" xml:space="preserve">
    <value>Container names can only contain lower case letters, numbers, and hyphens, and must begin with a letter or number. The name can't contain consecutive hypens.</value>
  </data>
  <data name="DataStreamField_FieldName_Invalid" xml:space="preserve">
    <value>Invalid format on the name used for your data stream field.  The name must be between 2 and 64 characters and include upper and lower case letters and numbers as well as - and _, it must start with a letter.</value>
  </data>
  <data name="DataStream_DeviceId_InvalidFormat" xml:space="preserve">
    <value>Invalid format on date stamp field name.  The timestamp field name may be between 3 and 64 characters and include upper and lower case letters and numbers, it must start with a letter.</value>
  </data>
  <data name="DataStream_TimeStamp_InvalidFormat" xml:space="preserve">
    <value>Invalid format on time stamp field name.  The timestamp field name may be between 3 and 64 characters and include upper and lower case letters and numbers, it must start with a letter.</value>
  </data>
  <data name="DataStream_AzureStorageName" xml:space="preserve">
    <value>Azure Storage Name</value>
  </data>
  <data name="Listener_DefaultResponse" xml:space="preserve">
    <value>Default Response</value>
  </data>
  <data name="Listener_FailedResponse" xml:space="preserve">
    <value>Failed Response</value>
  </data>
  <data name="DataStream_StreamType_PostgreSQL" xml:space="preserve">
    <value>Postgresql</value>
  </data>
  <data name="DataStreamField_IsKey" xml:space="preserve">
    <value>Is Key Field</value>
  </data>
  <data name="DataStreamField_IsKey_Description" xml:space="preserve">
    <value>Field should be treated as a unique key.</value>
  </data>
  <data name="DataStream_CreateTableDDL" xml:space="preserve">
    <value>Create Table DDL</value>
  </data>
  <data name="DataStream_CreateTableDDL_Help" xml:space="preserve">
    <value>You can provide DDL that will be executed on the target RDBMS to create the table. This will only be executed one. Currently does not support updating table structure.</value>
  </data>
  <data name="DataStream_DbSchema" xml:space="preserve">
    <value>Database Schema</value>
  </data>
  <data name="DataStreamField_IsDatabaseGenerated" xml:space="preserve">
    <value>Is Generated from Storage</value>
  </data>
  <data name="DataStreamField_IsDatabaseGenerated_Help" xml:space="preserve">
    <value>If this is set, this value won't be inserted and can't be updated.</value>
  </data>
  <data name="Custom_AccountId" xml:space="preserve">
    <value>Account Id</value>
  </data>
  <data name="Custom_AccountPassword" xml:space="preserve">
    <value>Password</value>
  </data>
  <data name="Custom_AccountPassword_Help" xml:space="preserve">
    <value>Your password will be stored in secure storage.  When you edit your custom module you will not see the original password however if you enter a new value, that new value will be saved</value>
  </data>
  <data name="Custom_Uri" xml:space="preserve">
    <value>URI</value>
  </data>
  <data name="Dictionary_Description" xml:space="preserve">
    <value>Provides a simple key value pair lookup dictionary</value>
  </data>
  <data name="Dictionary_Help" xml:space="preserve">
    <value>Provides a simple key value pair lookup dictionary</value>
  </data>
  <data name="Dictionary_Title" xml:space="preserve">
    <value>Dictionary</value>
  </data>
  <data name="Dictionary_Type" xml:space="preserve">
    <value>Dictionary Type</value>
  </data>
  <data name="Dictionary_Type_NuvIoT" xml:space="preserve">
    <value>NuvIoT</value>
  </data>
  <data name="Dictionary_Type_Redis" xml:space="preserve">
    <value>Redis</value>
  </data>
  <data name="Dictionary_Type_Select" xml:space="preserve">
    <value>-select dictionary type-</value>
  </data>
  <data name="Dictionary_Password" xml:space="preserve">
    <value>Password</value>
  </data>
  <data name="Dictionary_Password_Help" xml:space="preserve">
    <value>Your password will be stored in secure storage.  When you edit your dictionary module you will not see the original password however if you enter a new value, that new value will be saved</value>
  </data>
  <data name="Dictionary_Uri" xml:space="preserve">
    <value>Uri</value>
  </data>
  <data name="DataStream_RedisPassword" xml:space="preserve">
    <value>Redis Server Passwords</value>
  </data>
  <data name="DataStream_RedisPassword_Help" xml:space="preserve">
    <value>Your Redis password will apply to all the redis servers in the cluster and will be stored securely on the server.  You will only see the password when you add a new redis server or change an existing one.</value>
  </data>
  <data name="DataStream_RedisServers" xml:space="preserve">
    <value>Redis Server URLs</value>
  </data>
  <data name="DataStream_StreamType_Redis" xml:space="preserve">
    <value>Redis</value>
  </data>
  <data name="DataStream_RedisServers_Help" xml:space="preserve">
    <value>Enter the URL of your Redis server, if you have a Redis cluster you can add multiple servers seperated by a , (comma).  If not provided, it will use the port 6379, if you need to provide a differnet port simply append it to the url such as myhost.net:1234</value>
  </data>
  <data name="AppCache_CacheType" xml:space="preserve">
    <value>Cache Type</value>
  </data>
  <data name="AppCache_CacheType_NuvIoT" xml:space="preserve">
    <value>NuvIoT Native</value>
  </data>
  <data name="AppCache_CacheType_Redis" xml:space="preserve">
    <value>Redis</value>
  </data>
  <data name="AppCache_Description" xml:space="preserve">
    <value>The Application Cache is a way that IoT applications can work with 3rd part or NuvIoT's native caching system.</value>
  </data>
  <data name="AppCache_Help" xml:space="preserve">
    <value>The Application Cache is a way that IoT applications can work with 3rd part or NuvIoT's native caching system.</value>
  </data>
  <data name="AppCache_Password" xml:space="preserve">
    <value>Password</value>
  </data>
  <data name="AppCache_Password_Help" xml:space="preserve">
    <value>Is your server is on a public network we highly recommend adding a strong password.  After you enter your password it will be stored in our securre storage on the server and will never be displayed when you edit your cache.  If you enter a new password the old password will be updated, but the change won't apply until you reload your instance.</value>
  </data>
  <data name="AppCache_SelectCacheType" xml:space="preserve">
    <value>-select cache type-</value>
  </data>
  <data name="AppCache_Title" xml:space="preserve">
    <value>Application Cache</value>
  </data>
  <data name="AppCache_Uri" xml:space="preserve">
    <value>Uri</value>
  </data>
  <data name="AppCache_Uri_Help" xml:space="preserve">
    <value>Enter the URI of your cache server.  If you have a cluster configuration, you can enter multiple servers seperated by a comma.  In addition if you are not using the default port (for example 6379 for Redis) you can enter the port number along with the URL seperated by a colon. Example: myhost.net:8080</value>
  </data>
  <data name="AppCache_CacheType_LocalInMemory" xml:space="preserve">
    <value>Local - In Memory</value>
  </data>
  <data name="Connection_Type_Kafka" xml:space="preserve">
    <value>Kafka</value>
  </data>
  <data name="Connection_Type_Redis" xml:space="preserve">
    <value>Redis</value>
  </data>
  <data name="Listener_ExchangeName" xml:space="preserve">
    <value>Exchange Name</value>
  </data>
  <data name="CusotmModule_CustomModuleType_DotNetAssembly" xml:space="preserve">
    <value>DotNet Assembly</value>
  </data>
  <data name="CustomModule_AuthenticationHeader" xml:space="preserve">
    <value>Authentication Header</value>
  </data>
  <data name="CustomModule_AuthenticationHeader_Help" xml:space="preserve">
    <value>Enter the full authorization header that will be added to the HTTP Header Authorization, this should include the authorization type.  This value will not be displayed when you edit your custom module and will be encrypted at rest.</value>
  </data>
  <data name="CustomModule_AuthenticationType" xml:space="preserve">
    <value>Uri Authentication Type</value>
  </data>
  <data name="CustomModule_AuthenticationType_Anonymous" xml:space="preserve">
    <value>Anonymous</value>
  </data>
  <data name="CustomModule_AuthenticationType_AuthenticationHeader" xml:space="preserve">
    <value>Authentication Header</value>
  </data>
  <data name="CustomModule_AuthenticationType_BasicAuth" xml:space="preserve">
    <value>Basic Authentication</value>
  </data>
  <data name="CustomModule_AuthenticationType_Select" xml:space="preserve">
    <value>-select uri authentication type-</value>
  </data>
  <data name="CustomModule_ContainerRepository" xml:space="preserve">
    <value>Container Repository</value>
  </data>
  <data name="CustomModule_ContainerTag" xml:space="preserve">
    <value>Container Tag</value>
  </data>
  <data name="CustomModule_CustomModuleType" xml:space="preserve">
    <value>Custom Module Type</value>
  </data>
  <data name="CustomModule_CustomModuleType_Container" xml:space="preserve">
    <value>Container</value>
  </data>
  <data name="CustomModule_CustomModuleType_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="CustomModule_CustomModuleType_Select" xml:space="preserve">
    <value>-select custom module type-</value>
  </data>
  <data name="CustomModule_CustomModuleType_WebFunction" xml:space="preserve">
    <value>Web Function</value>
  </data>
  <data name="CustomModule_DotNetAssembly" xml:space="preserve">
    <value>.NET Assembly</value>
  </data>
  <data name="CustomModule_DotNetClass" xml:space="preserve">
    <value>.NET Class</value>
  </data>
  <data name="CustomModule_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="CustomModule_Uri" xml:space="preserve">
    <value>Uri</value>
  </data>
  <data name="CustomModule_Uri_AccountId" xml:space="preserve">
    <value>Uri Account Id</value>
  </data>
  <data name="CustomModule_Uri_AccountPassword" xml:space="preserve">
    <value>Uri Account Password</value>
  </data>
  <data name="CustomModule_Uri_AccountPassword_Help" xml:space="preserve">
    <value>Enter the password to be used for Basic Auth for your web function call. This will not be displayed when you edit your custom module and will be encrypted at rest.</value>
  </data>
  <data name="CustomModule_ContainerRepository_Select" xml:space="preserve">
    <value>-select container repository-</value>
  </data>
  <data name="CustomModule_ContainerTag_Select" xml:space="preserve">
    <value>-select container tag-</value>
  </data>
  <data name="AppCache_InitializationValues" xml:space="preserve">
    <value>Initialization Values</value>
  </data>
  <data name="ApplicationCacheValue_Description" xml:space="preserve">
    <value>Default values to be used to initialize the application cache with lookup values</value>
  </data>
  <data name="ApplicationCacheValue_Help" xml:space="preserve">
    <value>Default values to be used to initialize the application cache with lookup values</value>
  </data>
  <data name="ApplicationCacheValue_Key" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="ApplicationCacheValue_Title" xml:space="preserve">
    <value>Cache Value</value>
  </data>
  <data name="ApplicationCacheValue_Value" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="ApplicationCacheValue_Value_Number" xml:space="preserve">
    <value>Number</value>
  </data>
  <data name="ApplicationCacheValue_Value_String" xml:space="preserve">
    <value>String</value>
  </data>
  <data name="ApplicationCacheValue_Value_Type" xml:space="preserve">
    <value>Value Type</value>
  </data>
  <data name="ApplicationCacheValue_Value_Type_Select" xml:space="preserve">
    <value>-select value type-</value>
  </data>
  <data name="ConnectionType_SerialPort" xml:space="preserve">
    <value>Serial Port</value>
  </data>
  <data name="SerialPort_BaudRate" xml:space="preserve">
    <value>Baud Rate</value>
  </data>
  <data name="SerialPort_PortName" xml:space="preserve">
    <value>Port Name</value>
  </data>
  <data name="Transmitter_TransmitterType_SerialPort" xml:space="preserve">
    <value>Serial Port</value>
  </data>
  <data name="Common_IsPublic_Help" xml:space="preserve">
    <value>If you create this object as a public object it will be available to other users to use and clone within their application.  You will be  the only person allowed to edit it.</value>
  </data>
  <data name="DataStream_StreamType_PointArrayStorage" xml:space="preserve">
    <value>Point Array Storage</value>
  </data>
  <data name="InputTranslator_Model" xml:space="preserve">
    <value>Model</value>
  </data>
  <data name="InputTranslator_ModelRevision" xml:space="preserve">
    <value>Model Revision</value>
  </data>
  <data name="InputTranslator_ModelRevision_Select" xml:space="preserve">
    <value>-select nuvai model revision-</value>
  </data>
  <data name="InputTranslator_Model_Select" xml:space="preserve">
    <value>-select nuvai model-</value>
  </data>
  <data name="InputTranslator_SevenSegmentParser" xml:space="preserve">
    <value>Seven Segement Display Parser</value>
  </data>
  <data name="TranslatorType_AIModel" xml:space="preserve">
    <value>NuvAI Model</value>
  </data>
  <data name="TranslatorType_SevenSegmentParser" xml:space="preserve">
    <value>Seven Segment Display Parser</value>
  </data>
  <data name="InputTranslator_SevenSegmentParser_Select" xml:space="preserve">
    <value>-select seven segment parser-</value>
  </data>
  <data name="Connection_Type_FTP" xml:space="preserve">
    <value>FTP</value>
  </data>
  <data name="DataaStream_SummaryLevel" xml:space="preserve">
    <value>Summary Level</value>
  </data>
  <data name="DataStream_SharedConnection" xml:space="preserve">
    <value>Shared Data Stream Connection</value>
  </data>
  <data name="DataStream_SummaryLevel_Help" xml:space="preserve">
    <value>If your data stream supports summary level it will contain a field called period that will support summary level fields such as hour, day, week, month</value>
  </data>
  <data name="SharedConnection_ConnectionType" xml:space="preserve">
    <value>Connection Type</value>
  </data>
  <data name="SharedConnection_Description" xml:space="preserve">
    <value>A Shared Connection is a common connection that be associated with a data stream writer or other external service.</value>
  </data>
  <data name="SharedConnection_Help" xml:space="preserve">
    <value>A Shared Connection is a common connection that be associated with a data stream writer or other external service.</value>
  </data>
  <data name="SharedConnection_Title" xml:space="preserve">
    <value>Shared Connection</value>
  </data>
  <data name="DataStream_SharedConnection_Select" xml:space="preserve">
    <value>-select shared connection-</value>
  </data>
  <data name="SharedConnection_AWS" xml:space="preserve">
    <value>AWS</value>
  </data>
  <data name="SharedConnection_Azure" xml:space="preserve">
    <value>Azure</value>
  </data>
  <data name="SharedConnection_ConnectionType_Select" xml:space="preserve">
    <value>-select connection type-</value>
  </data>
  <data name="SharedConnection_Database" xml:space="preserve">
    <value>Database</value>
  </data>
  <data name="SharedConnection_Redis" xml:space="preserve">
    <value>REDIS</value>
  </data>
  <data name="DataStream_SummaryData" xml:space="preserve">
    <value>Contains Summary Level Data</value>
  </data>
  <data name="DataStream_SummaryData_Help" xml:space="preserve">
    <value>This data stream contains data this is already summarized over periods of time.  It must contain a field named "period" that will be populated with "hour", "day", "week" or "month".</value>
  </data>
  <data name="DataStream_StreamType_GeoSpatial" xml:space="preserve">
    <value>Geo Spatial</value>
  </data>
  <data name="Connection_MQTT_SharedBroker" xml:space="preserve">
    <value>Shared MQTT Broker</value>
  </data>
  <data name="Connection_Type_HostedMQTT" xml:space="preserve">
    <value>Internally Hosted MQTT</value>
  </data>
  <data name="Translator_Type_Script" xml:space="preserve">
    <value>Script</value>
  </data>
  <data name="Common_EditScript" xml:space="preserve">
    <value>Edit Script</value>
  </data>
  <data name="SharedConnection_MQTT" xml:space="preserve">
    <value>MQTT</value>
  </data>
  <data name="SharedConnection_Mqtt_Password" xml:space="preserve">
    <value>MQTT Password</value>
  </data>
  <data name="SharedConnection_Mqtt_Port" xml:space="preserve">
    <value>MQTT Port</value>
  </data>
  <data name="SharedConnection_Mqtt_Secure" xml:space="preserve">
    <value>Secure/TLS</value>
  </data>
  <data name="SharedConnection_Mqtt_Url" xml:space="preserve">
    <value>MQTT Url</value>
  </data>
  <data name="SharedConnection_Mqtt_UserName" xml:space="preserve">
    <value>MQTT User Name</value>
  </data>
  <data name="SharedConnection_Server" xml:space="preserve">
    <value>Server</value>
  </data>
  <data name="SharedConnection_Server_Password" xml:space="preserve">
    <value>Server Password</value>
  </data>
  <data name="SharedConnection_Server_Port" xml:space="preserve">
    <value>Server Port</value>
  </data>
  <data name="SharedConnection_Server_Url" xml:space="preserve">
    <value>Server Url</value>
  </data>
  <data name="SharedConnection_Server_UserName" xml:space="preserve">
    <value>Server User Name</value>
  </data>
  <data name="Planners_Title" xml:space="preserve">
    <value>Planners</value>
  </data>
  <data name="DataStreams_Title" xml:space="preserve">
    <value>Data Stream Writers</value>
  </data>
  <data name="InputTranslators_Title" xml:space="preserve">
    <value>Input Translators</value>
  </data>
  <data name="Listeners_Title" xml:space="preserve">
    <value>Listeners</value>
  </data>
  <data name="OutputTranslators_Title" xml:space="preserve">
    <value>Output Translators</value>
  </data>
  <data name="Sentinels_Title" xml:space="preserve">
    <value>Sentintels</value>
  </data>
  <data name="SharedConnections_Title" xml:space="preserve">
    <value>Shared Connections</value>
  </data>
  <data name="Transmitters_Title" xml:space="preserve">
    <value>Transmitters</value>
  </data>
  <data name="Common_Icon" xml:space="preserve">
    <value>Icon</value>
  </data>
  <data name="Common_Category" xml:space="preserve">
    <value>Category</value>
  </data>
  <data name="Common_Category_Select" xml:space="preserve">
    <value>-select category-</value>
  </data>
</root>